using UniRx;
using System;
using Etermax.Web.Client.Error;

namespace Etermax.Web.Client.ReactiveExtensions {
    public static class HttpReactiveExtensions {
        private static IObservable<T> CatchHttpError<T>(this IObservable<T> observable, int statusCode,
            Func<HttpWebResponseError, IObservable<T>> errorHandler) where T: HttpWebResponse{
            return observable.Catch((HttpWebResponseError error) => {
                switch (statusCode) {
                    case (int) HttpStatusCode.Any400:
                        return (error.StatusCode >= 400 && error.StatusCode < 500)
                            ? errorHandler(error)
                            : observable;
                    case (int)HttpStatusCode.Any500:
                        return (error.StatusCode >= 500) ? errorHandler(error) : observable;
                    default:
                        return (statusCode == error.StatusCode) ? errorHandler(error) : observable;
                }
            });
        }

        public static IObservable<T> ThrowOn<T>(this IObservable<T> observable, HttpStatusCode statusCode,
            Func<HttpWebResponseError, Exception> errorMapper) where T : HttpWebResponse {
            return observable.CatchHttpError((int)statusCode, error => Observable.Throw<T>(errorMapper(error)));
        }
        
        public static IObservable<T> ThrowOn<T>(this IObservable<T> observable, int statusCode,
            Func<HttpWebResponseError, Exception> errorMapper) where T : HttpWebResponse {
            return observable.CatchHttpError(statusCode, error => Observable.Throw<T>(errorMapper(error)));
        }
    }
}