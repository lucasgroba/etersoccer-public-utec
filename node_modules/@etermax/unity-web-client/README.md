[![Name Badge][name]][name-link]
[![Version Badge][version]][version-link]

[![Pipeline Badge][pipeline]][pipeline-link]
[![Open Issues Badge][open-issues]][open-issues-link]
[![Open Merge Requests Badge][open-merge-requests]][open-merge-requests-link]

[![Slack Badge][slack]][slack-link]

[name]: https://badges.etermax.com/packageJson?key=name&label=name&color=yellow&project=unity-tools/unity-web-client
[name-link]: package.json
[version]: https://badges.etermax.com/packageJson?key=version&label=version&project=unity-tools/unity-web-client
[version-link]: package.json
[pipeline]: https://badges.etermax.com/pipeline?project=unity-tools/unity-web-client
[pipeline-link]: https://gitlab.etermax.net/unity-tools/unity-web-client/pipelines
[open-issues]: https://badges.etermax.com/open-issues?project=unity-tools/unity-web-client
[open-issues-link]: https://gitlab.etermax.net/unity-tools/unity-web-client/issues?scope=all&utf8=âœ“&state=opened
[open-merge-requests]: https://badges.etermax.com/open-merge-requests?project=unity-tools/unity-web-client
[open-merge-requests-link]: https://gitlab.etermax.net/unity-tools/unity-web-client/merge_requests
[slack]: https://badges.etermax.com/slack?channel=ask-platform-team
[slack-link]: https://etermax.slack.com/app_redirect?channel=ask-platform-team

# Unity Web Client

# Description

This package provides a http web client to generate requests.

Methods Supported: `GET`, `DELETE`, `POST`, `PUT`

Also the module works with `JsonObject` package to make jsons easily.

# Prerequisites

Add the dependency to your `package.json`.

```json
"dependencies": {
    "@etermax/unity-web-client": "VERSION"
}
```

# Assembly Definitions

```json
Etermax.Web
Etermax.Web.Editor
```

## Peer dependencies

To use this module you must add the following dependencies to your project

```json
"@etermax/unity-rx": "6.2.2"
"@etermax/observable-extensions": "1.2.1"
```

# Usage

## Get

```csharp
var webClient = ReactiveWebClientBuilder.New().Build();
webClient
    .Get(GetUrl)
    .Send()
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Post

```csharp
var webClient = ReactiveWebClientBuilder.New().Build();
var jsonArray = JsonArray<int>.Create().Add(1).Add(2).Add(3);
var jsonObject = JsonObject.Create()
    .Add("id", 123)
    .Add("name", "Example");
var json = jsonObject.ToString();

webClient
    .Post(PostUrl)
    .Send(json)
    //.SendJson(json)
    //.SendJsonObject(jsonObject)
    //.SendJsonArray(jsonArray)
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Delete

```csharp
var webClient = ReactiveWebClientBuilder.New().Build();
webClient
    .Delete(DeleteUrl)
    .Send()
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Put

```csharp
var webClient = ReactiveWebClientBuilder.New().Build();
var jsonObject = JsonObject.Create().Add("title", "foo").Add("body", "bar").Add("userId", "2");
webClient
    .Put(PutUrl)
    .Send(jsonObject)
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Add Headers

To add header to a request just use the method `PutHeader`.

```csharp
webClient
    .Post(PostUrl)
    .PutHeaders("Content-Type", "application/json")
    .Send(jsonObject)
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Add Query Params

To add query params to a request just use the method `AddQueryParam`.

```csharp
var httpWebRequest = webClient
            .Get(GetUrl)
            .AddQueryParam("id", "3")
            .AddQueryParam("user", "Example");

Debug.Log(httpWebRequest.AbsUrl);

//Output: https://jsonplaceholder.typicode.com/posts?id=3&user=Example
```

## Add Bearer Authentication

The module provides a method `AddBearerAuthentication` to set up Bearer Authentication header.

```csharp
var httpWebRequest = webClient
    .Get(GetUrl)
    .AddBearerAuthentication("myToken")
    .Send()
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## Set Certificate Handler

You can set an ICertificateHandler to validate the url certificate. By default the value is null.

```csharp
var httpWebRequest = webClient
    .Get(GetUrl)
    // Implement your ICredentialsHandler
    .SetCredentialsHandler(new AcceptingAllCertificatesHandler()) 
    .Send()
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });

public class AcceptingAllCertificatesHandler : ICertificateHandler
{
    public bool ValidateCertificate(byte[] certificateData)
    {
        // Compare certificateData with public key here.
        return true;
    }
}
```

## Add Request and Response Proxies

You can add requests and responses proxies to manipulate the request before sending or validating a response before returning it. This is very useful when you need to sign with a token every request.

**IMPORTANT**: You need to return a new instance of the request, do not mutate the request variable.

### Request Proxies
You can add one or more request proxies with the **AddRequestProxy** method.
```csharp
var client = ReactiveWebClientBuilder.New()
            .AddRequestProxy(new AuthProxy())
            .Build();

public class AuthProxy : IRequestProxy
{
    public IObservable<IHttpWebRequest> Proxy(IHttpWebRequest request)
    {        
        return Observable.Start(() =>
        {
            return request.AddBearerAuthentication("myToken");            
        });
        
    }
}
```

### Response Proxy
You can only add one response proxy with the **WithResponseProxy** method.

```csharp
var client = ReactiveWebClientBuilder.New()
            .WithResponseProxy(new DebugWebResponseProxy())
            .Build();
    
public class DebugWebResponseProxy : IResponseProxy
{
    public IObservable<HttpWebResponse> Proxy(IHttpWebRequest request, HttpWebResponse response)
    {
        return Observable.Start(() =>
        {
            Debug.Log("Request: " + request.GetMethod() + " -> " + request.GetAbsUrl());
            Debug.Log("Response: " + response.StatusCode + " -> " + response.Body);

            return response;
        }, Scheduler.MainThread);
    }
}
```

## Catch 4xx Status Codes

To catch an error like a 400, 404, 40x or 500 you can use. Also you can catch `Any400` & `Any500`.

```csharp
webClient
    .Get(GetUrl)
    .Send()
    .ThrowOn(HttpStatusCode.NotFound, httWebErrorResponse => new SomethingNotFoundException())
    .ThrowOn(HttpStatusCode.Unauthorized, httWebErrorResponse => new UnauthorizedException())
    .ThrowOn(HttpStatusCode.InternalServerError, httWebErrorResponse => new SomethingWentWrongWithServer())
    .ThrowOn(HttpStatusCode.Any400, httWebErrorResponse => new SomethingGeneralException())
    .ThrowOn(HttpStatusCode.Any500, httWebErrorResponse => new SomethingGeneralException())
    .Subscribe(httpWebResponse => {
        Debug.Log(httpWebResponse.StatusCode);
        Debug.Log(httpWebResponse.RawData);
        Debug.Log(httpWebResponse.Headers);
        Debug.Log(httpWebResponse.Body);
    });
```

## NetworkException

When something goes wrong with the network a NetworkException will be throw.

```csharp
webClient
    .Put(NotExistingUrl)
    .Send()
    .Subscribe(
        response => { }, exception => {
            var networkError = (NetworkException) exception;
            Debug.Log(networkError.Description);
        }
    );

// Output: Request timeout
```

## Timeout

You can set up the timeout per request.

```csharp
webClient
    .Put(NotExistingUrl)
    .Timeout(2)
    .Send()
    .Subscribe(
        response => { }, exception => {
            var networkError = (NetworkException) exception;
            Debug.Log(networkError.Description);
        }
    );
```

## Path Params

You can set your template url and replace path params for the request. If a param is not present in the url a `PathParamInUrlException` will be throw.

You can use colon or not in the key.

```csharp
var url = "http:://etermax.com/games/:gameId/users/:userId";
var httpWebRequest = _webClient
    .Get(url)
    .ReplacePathParam(":gameId", "TST")
    .ReplacePathParam("userId", "12345");

Debug.Log(httpWebRequest.AbsUrl);

//OUTPUT: http:://etermax.com/games/TST/users/12345
```

# Response

The response will contain

`HttpStatusCode`: (enum, casteable to int)

`Body`: (string)

`BodyAsJsonObject`: (jsonObject, null if it's an array)

`BodyAsJsonArray`: (jsonArray, null if it's an object)

# Logger

You can inject an ILogger implementation to debug requests and responses.

```csharp
_webClient = ReactiveWebClientBuilder.New().WithLogger(new WebClientLogger()).Build() 
```

# Mocking WebClient

Is it possible to mock web client to easily create test for infrastructure layer. This mock object is provided by the module and it's a mirror of the webClient itself.

When you create the mock object you set up spectations that need to match when the real service will call. If some spectation does not match the mock object will throw an exception and tell you which was expected. 

## Example

```csharp
var userName = "UserName";
var responseBody = JsonObject.Create().Add("name", userName).ToString();
var response = return new HttpWebResponse(HttpStatusCode.OK, responseBody, new byte[0], new Dictionary<string, string>());
var _webClient = WebClient.Mock().WhenGet("http://some.endpoint/users").Responds(() => Observable.Return(response));

var testSubscription = new ExampleService(_webClient)
    .GetUser()
    .Test()
    .AssertValue(userResult => userResult.name == userName);
````

## Mock API

```csharp
_webClient = WebClient.Mock()
//			.WhenPut()
//			.WhenDelete()
//			.WhenPost()
			.WhenGet(url)
			.WithPathParam("somePathParamKey", "pathParamValue")
			.WithHeaders("headerKey", "headerValue")
			.WithTimeout(10)
			.WithUrl("specific url") //Url also is validate on Methods WhenGet, WhenPost...
			.WithQueryParam("paramName", "paramValue")
//				.WithJsonResponds("Json body sent in the request",() => Observable.Return(httpResponse))
//				.WithJsonObjectResponds(JsonObject, () => Observable.Return(httpResponse)) Validate JsoObject.Tostring vs Service JsonObject.ToString()
//				.WithJsonArrayResponds(JsonArray, () => Observable.Return(httpResponse)) Validate JsonArray.Tostring vs Service JsonArray.ToString())
			.Responds(() => Observable.Return(httpResponse));
```

# Dependencies

```
"@etermax/unity-json-object": "1.x",
"@etermax/unity-reactivex": "8.x",
"@etermax/unity-logger": "1.0.0",
"@etermax/net-json-35": "1.0.9"
```

# DevDependencies

```
"@etermax/nsubstitute": "2.0.3-1"
```
